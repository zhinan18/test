package  {	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.*;		public class Racing3D extends MovieClip {		private var viewSprite:Sprite; // everything		private var worldSprite:Sprite; // ground, trees, car				// references to objects		private var car:Car;		private var ground:Ground;		private var worldObjects:Array; // trees and car				// keyboard input		private var leftArrow, rightArrow, upArrow, downArrow: Boolean;				// car direction and speed		private var dir:Number;		private var speed:Number;				public function Racing3D() {						// create the world and center it			viewSprite = new Sprite();			viewSprite.x = 275;			viewSprite.y = 350;			addChild(viewSprite);						// add an inner sprite to hold everything, lay it down			worldSprite = new Sprite();			worldSprite.rotationX = -90;			viewSprite.addChild(worldSprite);						// add the game map as the ground to the terrain, scale up by 10x			ground = new Ground();			ground.scaleX = 20;			ground.scaleY = 20;			worldSprite.addChild(ground);						// create trees where tree bases are located			worldObjects = new Array();			for(var i:int=0;i<ground.numChildren;i++) { // loop through children				if (ground.getChildAt(i) is TreeBase) { // found a tree base					var tree:Tree = new Tree();					tree.gotoAndStop(Math.ceil(Math.random()*3)); // random tree					tree.x = ground.getChildAt(i).x*20; // set location					tree.y = ground.getChildAt(i).y*20;					tree.scaleX = 10; // make tree the proper size					tree.scaleY = 10;					tree.rotationX = 90; // stand tree up					worldSprite.addChild(tree);					worldObjects.push(tree); // remeber tree				}			}						// add car			car = new Car();			car.rotationX = 90; // stand up			worldSprite.addChild(car);			worldObjects.push(car);					// initial direction and speed			dir = 90.0;			speed = 0.0;						// z-index sort			zSort();					// respond to key events			stage.addEventListener(KeyboardEvent.KEY_DOWN,keyPressedDown);			stage.addEventListener(KeyboardEvent.KEY_UP,keyPressedUp);						// advance game			addEventListener(Event.ENTER_FRAME, moveGame);					}				// set arrow variables to true		public function keyPressedDown(event:KeyboardEvent) {			if (event.keyCode == 37) {				leftArrow = true;			} else if (event.keyCode == 39) {				rightArrow = true;			} else if (event.keyCode == 38) {				upArrow = true;			} else if (event.keyCode == 40) {				downArrow = true;			}		}				// set arrow variables to false		public function keyPressedUp(event:KeyboardEvent) {			if (event.keyCode == 37) {				leftArrow = false;			} else if (event.keyCode == 39) {				rightArrow = false;			} else if (event.keyCode == 38) {				upArrow = false;			} else if (event.keyCode == 40) {				downArrow = false;			}		}				// main game function		public function moveGame(e) {							// see if turning left or right			var turn:Number = 0;			if (leftArrow) {				turn = .3;			} else if (rightArrow) {				turn = -.3;			}					// if up arrow pressed, then accelerate, otherwise decelerate			if (upArrow) {				speed += .1;				if (speed > 5) speed = 5; // limit			} else {				speed -= .05;				if (speed < 0) speed = 0; // limit			}						// if not on the road, then slow down			if (!ground.road.hitTestPoint(275,350,true)) {				speed *= .95;			}					// if moving, then move and turn			if (speed != 0) {				movePlayer(-speed*10);				turnPlayer(Math.min(2.0,speed)*turn);				zSort();							}					}				private function movePlayer(d) {						// move player by moving terrain in opposite direction			worldSprite.x += d*Math.cos(dir*2.0*Math.PI/360);			worldSprite.z += d*Math.sin(dir*2.0*Math.PI/360);						// move car opposite of terrain to keep in place			car.x -= d*Math.cos(dir*2.0*Math.PI/360);			car.y += d*Math.sin(dir*2.0*Math.PI/360);		}						private function turnPlayer(d) {						// change direction			dir += d;						// rotate world to change view			viewSprite.rotationY = dir-90;						// rotate all trees and car to face the eye			for(var i:int=0;i<worldObjects.length;i++) {				worldObjects[i].rotationZ -= d;			}		}				// sort all objects so the closest ones are highest in the display list		private function zSort() {			var objectDist:Array = new Array();			for(var i:int=0;i<worldObjects.length;i++) {				var z:Number = worldObjects[i].transform.getRelativeMatrix3D(root).position.z;				objectDist.push({z:z,n:i});			}			objectDist.sortOn( "z", Array.NUMERIC | Array.DESCENDING );			for(i=0;i<objectDist.length;i++) {				worldSprite.addChild(worldObjects[objectDist[i].n]);			}		}			}	}